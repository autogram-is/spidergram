import process from 'node:process';
import path from 'node:path';
import { PathLike } from 'node:fs';
import { readFile, writeFile } from 'node:fs/promises';
import is from '@sindresorhus/is';
import _ from 'lodash';

import {
  Storage as FileStore,
  Configuration as FileConfiguration,
} from 'typefs';
import { Config as ArangoConfig } from 'arangojs/connection';
import * as dotenv from 'dotenv';

import { ArangoStore } from './arango-store.js';
import { NormalizedUrl, ParsedUrl, UrlMutators } from '@autogram/url-tools';

dotenv.config();

export interface ProjectConfig {
  /**
   * A unique name identifying the current project; used
   * for reporting purposes and to generate an Arango database
   * name if no explicit graph configuration options are supplied.
   *
   * @default 'spidergram'
   * @type {string}
   */
  name: string;

  /**
   * An optional description of the project and its purpose.
   *
   * @type {string}
   */
  description?: string;

  /**
   * The directory where data generated by the project is stored.
   * This defaults to the current working directory (process.cwd()),
   * and can be overriden by setting the SPIDERGRAM_PROJECT_ROOT
   * environment variable.
   *
   * @type {string}
   */
  root: string;

  /**
   * Configuration for the project's storage buckets; by default
   * a single file bucket in the `./storage` directory of the node.js
   * project will be used.
   *
   * @example
   * const files = {
   *	 default: 'downloads',
   *   disks: {
   *	   downloads: {
   *	     driver: 'file',
   *		   root: './storage/downloads',
   *		   jail: true,
   *	   },
   *	   config: {
   *	     driver: 'file',
   *		   root: './storage/config',
   *		   jail: true,
   *	   }
   *   }
   * };
   *
   * @type {FileConfiguration}
   */
  files: FileConfiguration;

  graph: {
    /**
     * Connection details for an Arango database server. If no
     * connection information is specified, a localhost server
     * and 'root' user will be used.
     *
     * @type {ArangoConfig}
     */
    connection: ArangoConfig;
  };

  /**
   * Settings for the project's default URL normalizer. These control
   * which URLs will be considered duplicates of each other. File-based
   * configuration of the project allows normalizer features to be turned
   * on and off, but in code a custom function can be supplied that takes
   * URL context (the page it appears on, etc) into account.
   *
   * @type {NormalizerOptions}
   */
  normalizer: NormalizerOptions;

  /**
   * The local path of the project's configuration file, if one exists.
   *
   * *NOTE:* This property is set by the
   *
   * @type {?string}
   */
  _configFilePath?: string;
}

export class Project {
  private static _instance?: Project;
  static normalizerOptions: NormalizerOptions = {};

  static get defaultConfigPath(): string {
    return (
      process.env.SPIDERGRAM_CONFIG_FILE ??
      path.join(
        process.env.SPIDERGRAM_PROJECT_ROOT ?? process.cwd(),
        'spidergram.json',
      )
    );
  }

  // This does NOT attempt to validate config data or populate defaults;
  // If the file was read successfully, its pathname will be saved in the
  // _configFilePath property and thus that property's absence can be used
  // as a signal that the config file either doesn't exist or is malformed.
  static async loadConfigFile(path: PathLike): Promise<Partial<ProjectConfig>> {
    return readFile(path, { flag: 'r' })
      .then(buffer => {
        const results = JSON.parse(buffer.toString());
        results._configFilePath = path.toString();
        return results;
      })
      .catch(() => Promise.resolve({}));
  }

  // Takes an options object and recursively populates its UNSET options with
  // default settings. If a key is set but its value is undefined, the default
  // value WILL NOT overwrite it.
  static async config(options: Partial<ProjectConfig> = {}): Promise<Project> {
    if (Project._instance === undefined) {
      let fileConfig: Partial<ProjectConfig> = {};
      if (is.nonEmptyStringAndNotWhitespace(options._configFilePath)) {
        fileConfig = await this.loadConfigFile(options._configFilePath);
      } else {
        fileConfig = await this.loadConfigFile(this.defaultConfigPath);
      }

      const fullConfig = _.defaultsDeep(
        options,
        fileConfig,
        projectConfigDefaults,
      );
      Project._instance = new Project(fullConfig);
    }
    return Project._instance as Project;
  }

  readonly name: string;
  readonly description?: string;
  readonly root: string;

  get files() {
    return FileStore.disk.bind(FileStore);
  }

  async graph(name?: string): Promise<ArangoStore> {
    return ArangoStore.open(
      name ??
        this.configuration.graph.connection.databaseName ??
        this.configuration.name,
      this.configuration.graph.connection,
    );
  }

  // Since we use a static factory to set things up, we can safely expect a
  // fully popualted configuration object here.
  private constructor(public readonly configuration: ProjectConfig) {
    this.configuration = _.defaultsDeep(configuration);
    this.name = this.configuration.name;
    this.description = this.configuration.description;
    this.root = this.configuration.root;

    FileStore.config = this.configuration.files;
    Project.normalizerOptions = this.configuration.normalizer;
    NormalizedUrl.normalizer = url =>
      parameterizedNormalizer(url, Project.normalizerOptions);
  }

  async saveConfig(path?: PathLike) {
    return writeFile(
      path ?? Project.defaultConfigPath,
      JSON.stringify(this.configuration),
      { flag: 'w' },
    );
  }
}

export const projectConfigDefaults: ProjectConfig = {
  name: 'spidergram',
  root: process.env.SPIDERGRAM_PROJECT_ROOT ?? process.cwd(),
  files: {
    default: 'downloads',
    disks: {
      config: {
        driver: 'file',
        root: path.join(
          process.env.SPIDERGRAM_PROJECT_ROOT ?? process.cwd(),
          './storage/config',
        ),
        jail: true,
      },
      downloads: {
        driver: 'file',
        root: path.join(
          process.env.SPIDERGRAM_PROJECT_ROOT ?? process.cwd(),
          './storage/downloads',
        ),
        jail: true,
      },
      output: {
        driver: 'file',
        root: path.join(
          process.env.SPIDERGRAM_PROJECT_ROOT ?? process.cwd(),
          './storage/output',
        ),
        jail: true,
      },
    },
  },
  graph: {
    connection: {
      url: process.env.SPIDERGRAM_ARANGO_URL ?? 'http://127.0.0.1:8529',
      auth: {
        username: process.env.SPIDERGRAM_ARANGO_USER ?? 'root',
        password: process.env.SPIDERGRAM_ARANGO_PASS ?? '',
      },
    },
  },
  normalizer: {
    forceProtocol: 'https:',
    forceLowercase: 'host',
    discardSubdomain: 'ww*',
    discardAnchor: true,
    discardAuth: true,
    discardIndex: '**/{index,default}.{htm,html,aspx,php}',
    discardSearch: '*',
    discardTrailingSlash: false,
    sortSearchParams: true,
  },
};

export interface NormalizerOptions {
  forceProtocol?: 'https:' | 'http:' | false;
  forceLowercase?:
    | 'host'
    | 'domain'
    | 'subdomain'
    | 'href'
    | 'pathname'
    | false;
  discardSubdomain?: string | false;
  discardAnchor?: boolean;
  discardAuth?: boolean;
  discardIndex?: string | false;
  discardSearch?: string;
  discardTrailingSlash?: boolean;
  sortSearchParams?: boolean;
}

export function parameterizedNormalizer(
  url: ParsedUrl,
  opts = Project.normalizerOptions,
): ParsedUrl {
  if (opts.forceProtocol) UrlMutators.forceProtocol(url, opts.forceProtocol);
  if (opts.forceLowercase)
    url[opts.forceLowercase] = url[opts.forceLowercase].toLocaleLowerCase();
  if (opts.discardSubdomain)
    UrlMutators.stripSubdomains(url, opts.discardSubdomain);
  if (opts.discardAnchor) UrlMutators.stripAnchor(url);
  if (opts.discardAuth) UrlMutators.stripAuthentication(url);
  if (opts.discardIndex) UrlMutators.stripIndexPages(url, opts.discardIndex);
  if (opts.discardSearch)
    UrlMutators.stripQueryParameters(url, opts.discardSearch);
  if (opts.discardTrailingSlash) UrlMutators.stripTrailingSlash(url);
  if (opts.sortSearchParams) url.searchParams.sort();
  return url;
}
