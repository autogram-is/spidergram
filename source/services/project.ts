import {Config as ArangoConfig} from 'arangojs/connection';
import {Storage as FileStore, Configuration as FileConfiguration} from 'typefs';
import * as dotenv from 'dotenv';
import {PartialDeep} from 'type-fest';
import {ArangoStore} from './arango-store.js';
import process from 'node:process';
import { PathLike } from 'node:fs';
import path from 'node:path';
import is from '@sindresorhus/is';
import { readFile } from 'node:fs/promises';

dotenv.config();

export interface ProjectConfig {
  /**
	 * A unique name identifying the current project; used
	 * for reporting purposes and to generate an Arango database
	 * name if no explicit graph configuration options are supplied.
	 *
	 * @default 'spidergram'
	 * @type {string}
	 */
  name: string;

  /**
	 * The directory where data generated by the project is stored.
   * This defaults to the current working directory (process.cwd()),
   * and can be overriden by setting the SPIDERGRAM_PROJECT_ROOT 
   * environment variable.
	 *
	 * @type {string}
	 */
  root: string;

  /**
	 * Configuration for the project's storage buckets; by default
	 * a single file bucket in the `./storage` directory of the node.js
	 * project will be used.
	 *
	 * @example
	 * const files = {
	 *	 default: 'downloads',
	 *   disks: {
	 *	   downloads: {
	 *	     driver: 'file',
	 *		   root: './storage/downloads',
	 *		   jail: true,
	 *	   },
	 *	   config: {
	 *	     driver: 'file',
	 *		   root: './storage/config',
	 *		   jail: true,
	 *	   }
	 *   }
	 * };
	 *
	 * @type {FileConfiguration}
	 */
  files: FileConfiguration;

  graph: {
    /**
		 * Connection details for an Arango database server. If no
		 * connection information is specified, a localhost server
		 * and 'root' user will be used.
		 *
		 * @type {ArangoConfig}
		 */
    connection: ArangoConfig;
  };

  _configFilePath?: string;
}

export class Project {
  private static _instance?: Project;
  options!: PartialDeep<ProjectConfig>;

  name: string;
  root: string;
  graph!: ArangoStore;
  get files() {
    return FileStore.disk.bind(FileStore);
  }

  private constructor(public readonly configuration: ProjectConfig) {
    this.name = configuration.name;
    this.root = configuration.root;
  }

  static get defaultConfigFilePath(): string {
    return process.env.SPIDERGRAM_CONFIG_FILE
      ?? path.join(process.env.SPIDERGRAM_PROJECT_ROOT ?? process.cwd(), 'config.json');
  }

  static async loadConfig(path: PathLike): Promise<PartialDeep<ProjectConfig>> {
    return readFile(path, { flag: 'r' })
      .then(buffer => {
        const results = JSON.parse(buffer.toString());
        results._configFilePath = path.toString();
        return results;
      })
      .catch((error: unknown) => {});
  }

  static async config(
    config?: PathLike | PartialDeep<ProjectConfig>,
  ): Promise<Project> {
    if (Project._instance === undefined) {
      config ??= Project.defaultConfigFilePath;
      let populatedConfig: ProjectConfig | undefined = undefined;
      let incomingOptions: PartialDeep<ProjectConfig> = {};

      // Is it a PathLike? We're getting the location of a config file.
      if (is.string(config) || is.urlInstance(config) || is.buffer(config)) {
        incomingOptions = await Project.loadConfig(config);
        populatedConfig = Project.mergeDefaults(incomingOptions);
      } else {
        incomingOptions = config;
        populatedConfig = Project.mergeDefaults(config);
      }

      Project._instance = new Project(populatedConfig);
      Project._instance.options = incomingOptions;
      Project._instance.graph = await ArangoStore.open(
        populatedConfig.graph.connection.databaseName ?? populatedConfig.name,
        populatedConfig.graph.connection,
      ).catch((error: unknown) => {
        throw new Error(`Could not connect to Arango server (${(error as Error).message})`);
      });

      FileStore.config = populatedConfig!.files;
    }
    return Project!._instance!;
  }

  private static mergeDefaults(options: PartialDeep<ProjectConfig> = {}): ProjectConfig {
    return {
      name: (options.name ?? projectConfigDefaults.name),
      root: (options.root ?? projectConfigDefaults.root),
      graph: {
        ...options.graph,
        ...projectConfigDefaults.graph,
      },
      files: {
        ...options.files,
        ...projectConfigDefaults.files,
      },
    };
  }
}

export const projectConfigDefaults: ProjectConfig = {
  name: 'spidergram',
  root: process.env.SPIDERGRAM_PROJECT_ROOT ?? process.cwd(),
  files: {
    default: 'storage',
    disks: {
      storage: {
        driver: 'file',
        root: path.join(process.env.SPIDERGRAM_PROJECT_ROOT ?? process.cwd(), 'storage'),
        jail: true,
      },
      config: {
        driver: 'file',
        root: path.join(process.env.SPIDERGRAM_PROJECT_ROOT ?? process.cwd(), 'config'),
        jail: true,
      },
    },
  },
  graph: {
    connection: {
      url: process.env.SPIDERGRAM_ARANGO_URL ?? 'http://127.0.0.1:8529',
      auth: {
        username: process.env.SPIDERGRAM_ARANGO_USER ?? 'root',
        password: process.env.SPIDERGRAM_ARANGO_PASS ?? '',
      },
    },
  },
}
